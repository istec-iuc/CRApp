# offline_scanner.py
import json
import ijson
import os
import requests
import lzma
from collections import defaultdict
from datetime import datetime


def deduplicate_cve_items(cve_items):
    seen_ids = set()
    unique_items = []

    for item in cve_items:
        cve_id = item.get('id')
        if cve_id and cve_id not in seen_ids:
            seen_ids.add(cve_id)
            unique_items.append(item)

    return unique_items


#def load_cve_database(json_path="cveOffline/CVE-all.json"):
def load_cve_database(paths, save_to_db=False):
    #We import the app.py for context
    from app import app 

    cve_items = []

    for path in paths:
        #Check if files exist in the path first, if not -> Download, then proceed
        if not os.path.exists(path):
            print(f"[ERROR] CVE JSON file not found at: {path}. Going to download it...")
            os.makedirs("cveOffline", exist_ok=True)  # create directory

            # Step 1: Get latest release info
            api_url = "https://api.github.com/repos/fkie-cad/nvd-json-data-feeds/releases/latest"
            resp = requests.get(api_url, timeout=10)
            resp.raise_for_status()
            release = resp.json()

            assets = release.get("assets", [])
            
            # Determine which file is missing
            base_name = os.path.basename(path)
            xz_name = base_name + ".xz"

            if not xz_name:
                print(f"[ERROR] No mapping for {base_name} found. Check the filename.")
                return []

            for asset in assets:
                name = asset['name']
                download_url = asset['browser_download_url']

                if name == xz_name:
                    xz_path = os.path.join("cveOffline", xz_name)
                    json_path = os.path.splitext(xz_path)[0]

                    print(f"Downloading {name} from {download_url}")
                    r = requests.get(download_url, stream=True)
                    r.raise_for_status()

                    with open(xz_path, 'wb') as f:
                        for chunk in r.iter_content(chunk_size=8192):
                            f.write(chunk)

                    #Extract .xz to .json
                    with lzma.open(xz_path) as f_in, open(json_path, 'wb') as f_out:
                        f_out.write(f_in.read())

                    print(f"✓ Downloaded and extracted: {name}")
                    break

        try:
            with open(path, 'rb', encoding='utf-8') as f:
                parser = ijson.items(f, 'cve_items.item')
                for item in parser:
                    # process and save
                    cve_items.append(item)

            #with open(path, 'r', encoding='utf-8') as f:
             #   data = json.load(f)
             #   cve_items.extend(data.get('cve_items', []))
        except json.JSONDecodeError:
            print(f"[ERROR] Invalid JSON format in {path}")
        except Exception as e:
            print(f"[ERROR] Failed to load CVE {path}: {e}") 

    if save_to_db:
        with app.app_context():  # Needed if calling outside the Flask app context
            print("⚙️ Starting CVE storage...")
            store_cves_to_db(cve_items)

    return build_cve_index(cve_items) if not save_to_db else None
    #return build_cve_index(cve_items) if cve_items else []


def build_cve_index(cve_items):
    #Dedublicate the merged CVE files
    cve_items = deduplicate_cve_items(cve_items)

    index = defaultdict(list)

    for item in cve_items:
        # Combine relevant searchable text fields
        text_blob = ''
        
        # Add descriptions
        for desc in item.get('descriptions', []):
            text_blob += desc.get('value', '') + ' '
        
        # Add CPE strings (match criteria)
        for config in item.get('configurations', []):
            for node in config.get('nodes', []):
                for cpe in node.get('cpeMatch', []):
                    text_blob += cpe.get('criteria', '') + ' '

        # Tokenize and index
        for word in set(text_blob.lower().split()):
            index[word].append(item)

    return index

#DATABASE LOGIC
def store_cves_to_db(cve_items):
    #We import the db from app.py
    #Move shared models to a separate file (for better structure) in order to avoid circular import (move the database things to a separate .py (db, Vulnerability))
    from app import db, Vulnerability, app 

    #stored = 0
    updated = 0
    inserted = 0
    for item in cve_items:
        cve_id = item.get("id")
        if not cve_id:
            continue

        # Skip existing ones
        #if Vulnerability.query.filter_by(cve_id=cve_id).first():
        #    continue

        # Get English description
        description = next(
            (desc["value"] for desc in item.get("descriptions", []) if desc["lang"] == "en"),
            ""
        )

        # Get CVSS score
        score = 0.0
        for version in ["cvssMetricV40", "cvssMetricV31", "cvssMetricV30", "cvssMetricV2"]:
            try:
                score = item['metrics'][version][0]['cvssData']['baseScore']
                print("SCORE: ")
                print(score)
                break
            except (KeyError, IndexError, TypeError):
                continue

        # Get component match strings
        components = []
        for config in item.get("configurations", []):
            for node in config.get("nodes", []):
                for match in node.get("cpeMatch", []):
                    comp = match.get("criteria")
                    if comp:
                        components.append(comp.lower())

        component_str = ", ".join(components)[:255] if components else "unknown"

        # Check if CVE already exists
        existing = Vulnerability.query.filter_by(cve_id=cve_id).first()

        if existing:
            # Check if anything needs updating
            changed = False
            if existing.description != description:
                existing.description = description
                changed = True

            if existing.cvss != score:
                existing.cvss = score
                changed = True

            if existing.component != component_str:
                existing.component = component_str
                changed = True

            if changed:
                updated += 1

            if changed % 500 == 0:
                db.session.commit()
                
        else:
            # Insert new
            vuln = Vulnerability(
                component=component_str,
                cve_id=cve_id,
                cvss=score,
                description=description,
            )
            db.session.add(vuln)
            inserted += 1

            if inserted % 500 == 0:
                db.session.commit()
                print("SAVEEEEEEED")


    db.session.commit()
    print(f"✓ Inserted {inserted} new CVEs.")
    print(f"✓ Updated {updated} existing CVEs.")
    count = Vulnerability.query.count()
    print(f"✅ Total vulnerabilities in DB: {count}")


    '''
        vuln = Vulnerability(
            component=component_str,
            cve_id=cve_id,
            cvss=score or 0.0,
            description=description,
        )
        db.session.add(vuln)
        stored += 1

    db.session.commit()
    print(f"✓ Stored {stored} new CVEs into the database.")
    '''


#def scan_vulnerabilities_offline(components, cve_data):
def scan_vulnerabilities_offline(components):
    #We import the db from app.py
    from app import db, Vulnerability, app 

    print('Components:')
    print(components)

    cve_files = [
    'cveOffline/CVE-all.json',
    'cveOffline/CVE-recent.json',
    'cveOffline/CVE-modified.json'
    ]

    print('START LOADING AND INDEXING THE CVE DATABASE')
    cve_index = load_cve_database(cve_files)
    print('END OF INDEXING. START SCANNING')
    
    results = []

    with app.app_context():
        vuln_count = Vulnerability.query.count()

    if vuln_count > 0:
        print('Loading CVEs from the database...')
        results = []

        with app.app_context():
            for comp in components:
                name = comp['component'].lower()

                # Query DB for vulnerabilities matching the component (simple substring match)
                matches = Vulnerability.query.filter(
                    Vulnerability.component.ilike(f"%{name}%")
                ).all()

                for v in matches:
                    results.append({
                        'component': name,
                        'cve': v.cve_id,
                        'cvss': v.cvss,
                        'desc': v.description or 'No description'
                    })
                    print('Scanned one item from DB:', v.cve_id)
    else:

        if cve_index is not None:
            for comp in components:
                name = comp['component'].lower()
                #version = comp.get('version', '').lower()

                matches = cve_index.get(name, [])

                for item in matches:
                    cve_id = item['id']

                    # Get description
                    description = next(
                        (d['value'] for d in item.get('descriptions', []) if d['lang'] == 'en'),'Açıklama yok')

                    # CVSS puanı en yüksek versiyona göre alınır, yoksa 'N/A' döner
                    cvss_versions = ["cvssMetricV40", "cvssMetricV31", "cvssMetricV30", "cvssMetricV3", "cvssMetricV2"]
                    cvss = "N/A"

                    for version in cvss_versions:
                        try:
                            cvss = item['metrics'][version][0]["cvssData"]["baseScore"]
                            break  # Bulduktan sonra döngüden çık
                        except (KeyError, IndexError, TypeError):
                            continue

                    results.append({
                        'component': name,
                        'cve': cve_id,
                        'cvss': cvss,
                        'desc': description
                    })
                    print('Scanned one item from JSON:')
                    print(cve_id)

    return results
